<html><head>

<title>Unplayed Game Tracker</title>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>


<script type="text/javascript">
function dateToStr(date_object) {
    const formattedDate = date_object.getFullYear() + '-' +
        String(date_object.getMonth() + 1).padStart(2, '0') + '-' + // getMonth() is 0-indexed
        String(date_object.getDate()).padStart(2, '0');
    return formattedDate;
}


function stringToDate(date_as_string) {
    const splitdate = date_as_string.split("-");
    return new Date(parseInt(splitdate[0]), parseInt(splitdate[1]) - 1, parseInt(splitdate[2]));
}

  function todayStr() {
    var today = new Date();
    return dateToStr(today);
  };
</script>

<script type="text/javascript">
var datedata = {{ datedata }};
function updateVariableStatsForSelectedDateRange() {
    var variableStatsStartingCount = document.getElementById("variable_stats_starting_count");
    var variableStatsEndingCount = document.getElementById("variable_stats_ending_count");
    var variableStatsNetChange = document.getElementById("variable_stats_net_change");
    var variableStatsGamesAcquired = document.getElementById("variable_stats_games_acquired");
    var variableStatsGamesPlayed = document.getElementById("variable_stats_games_played");

    var startDate = stringToDate(document.getElementById('start_date_str').innerHTML);
    var endDate = stringToDate(document.getElementById('end_date_str').innerHTML);

    var starting_count = 0;
    var games_acquired_count = 0;
    var games_played_count = 0;
    var current_day_count = 0;
    var begin_tracking_acquired_played = false;
    for (const dateinfo of datedata) {
        const this_date = dateinfo[0];
        current_day_count = dateinfo[1];
        const games_acquired_on_date = dateinfo[2];
        const games_played_on_date = dateinfo[3];

        if (dateToStr(this_date) === dateToStr(startDate)) {
            starting_count = current_day_count;
            variableStatsStartingCount.innerHTML = starting_count;
            begin_tracking_acquired_played = true;
        }

        if (begin_tracking_acquired_played) {
            games_acquired_count += games_acquired_on_date;
            games_played_count += games_played_on_date;
        }

        if (dateToStr(this_date) === dateToStr(endDate)) {
            break;
        }
    }

    variableStatsEndingCount.innerHTML = current_day_count;
    var net_change = current_day_count - starting_count;
    if (net_change > 0) {
        net_change = "+" + net_change;
    }
    variableStatsNetChange.innerHTML = net_change;
    variableStatsGamesAcquired.innerHTML = games_acquired_count;
    variableStatsGamesPlayed.innerHTML = games_played_count;
};
</script>

<script type="text/javascript">
  google.load('visualization', '1', {packages: ['controls', 'charteditor']});
  google.setOnLoadCallback(drawChart);
  //google.charts.load('current', {'packages':['corechart', 'line']});
  //google.charts.setOnLoadCallback(drawChart);

  function drawChart() {

    var data = new google.visualization.DataTable();
    data.addColumn('date', 'Date');
    data.addColumn('number', 'Game Count');
    data.addColumn({type: 'string', role: 'tooltip', p: {'html': true}});
    data.addRows( {{ datatable }} );

    var options = {
      vAxis: {
        title: 'Game Count',
        format: '#',
        gridlines: {count: -1},
        //viewWindowMode: 'maximized',
        //viewWindow: {min: {{ vertical_min }}, max: {{ vertical_max }}},
      },
      hAxis: {
        title: 'Date',
        format: 'M/d/yy',
      },
      legend: {
        position: 'none',
      },
      tooltip: {
        trigger: 'both',
        isHtml: true,
      },
      explorer: {
        actions: ['dragToZoom', 'rightClickToReset'],
        axis: 'horizontal',
        maxZoomIn: 0.01,
        keepInBounds: true,
      },
      // empty trendlines necessary for toggle button
      trendlines: {},
      title: 'Unplayed Game Counts',
      width: 900,
      height: 500
    };

    //var chart_div = document.getElementById('chart_div');
    //var chart = new google.visualization.LineChart(chart_div);

    // https://stackoverflow.com/questions/43368734/custom-zoom-to-google-line-chart
    // https://jsfiddle.net/hicaro/vk8oaryy/8/
    var dash = new google.visualization.Dashboard(document.getElementById('dashboard_div'));
    var chart = new google.visualization.ChartWrapper({
        chartType: 'LineChart',
        containerId: 'chart_div',
        options: options
    });
    var control = new google.visualization.ControlWrapper({
        controlType: 'ChartRangeFilter',
        containerId: 'control_div',
        options: {
            filterColumnIndex: 0,
            ui: {
                chartOptions: {
                    height: 50,
                    width: 900,
                    chartArea: {
                        height: '100%',
                        width: '70%',
                        left: '15%'
                    }
                }
            }
        },
        state: {
            range: {
                start: new Date(2017, 6, 30)
            }
        }
    });
    dash.bind([control], [chart]);
    //dash.draw(data);

    // define our static image function (calling getImageURI)
    function setStatic() {
      var chartObject = chart.getChart();
      if (chartObject) {
        document.getElementById('png').innerHTML = '<img src="' + chartObject.getImageURI() + '">';
      }
    };

    // wait for the chart to finish drawing before initializing our static image
    google.visualization.events.addListener(chart, 'ready', setStatic);

    // whenever our chart changes, redraw the static image
    var observer = new MutationObserver(setStatic);
    google.visualization.events.addListener(chart, 'ready', function() {
      observer.observe(chart_div, {
        childList: true,
        subtree: true,
      });
    });

    // show extra game information when we mouseover a specific day
    google.visualization.events.addListener(chart, 'onmouseover', function () {
      //toggleStaticImage();
    });

    // show permanent game info when we click a specific day
    google.visualization.events.addListener(chart, 'select', function () {
      //toggleStaticImage();
    });

    // NOTE: https://stackoverflow.com/questions/45764587/google-visualization-explorer-options-wont-have-any-effect-after-chart-redraw
    // tl;dr redrawing instead of rebuilding breaks explorer, fixed "next release" says 2017-08-19

    // the trendlines button toggles the existence of our trendline
    document.getElementById('trendline_toggle').addEventListener('click', function () {
      if (Object.keys(options.trendlines).length > 0) {
        options.trendlines = {};
      } else {
        options.trendlines = {
          0: {
            type: 'polynomial',
            degree: document.getElementById('trendline_degree').value,
            color: 'green',
          },
        };
      }
      //chart.draw(data, options)
      dash.draw(data);
    });

    // changing the trendline degree should redraw the trendline
    document.getElementById('trendline_degree').addEventListener('change', function () {
      options.trendlines[0].degree = this.value;
      //chart.draw(data, options);
      dash.draw(data);
    });

    //chart.draw(data, options);
    dash.draw(data);


    // Set the end date input to today by default
    //var today = new Date();
    //var todayString = today.toISOString().split('T')[0];
    document.getElementById('end_date').value = todayStr();

    function applyDatesExceptControlRange() {
      var startDateInput = document.getElementById('start_date').value;
      var endDateInput = document.getElementById('end_date').value;

      var startDateStr = document.getElementById('start_date_str');
      var endDateStr = document.getElementById('end_date_str');
      startDateStr.innerHTML = startDateInput;
      endDateStr.innerHTML = endDateInput;
      updateVariableStatsForSelectedDateRange();
      updateUnplayedGamesHighlighting();
    }

    function applyDates() {
      var startDateInput = document.getElementById('start_date').value;
      var endDateInput = document.getElementById('end_date').value;
  
      if (startDateInput && endDateInput) {
        var startDate = new Date(startDateInput);
        var endDate = new Date(endDateInput);
    
        // Validate that start is before end
        if (startDate > endDate) {
          alert('Start date must be before end date');
          return;
        }
    
        control.setState({
          range: {
            start: startDate,
            end: endDate
          }
        });
        control.draw();
        applyDatesExceptControlRange();
      }
    };

    // changing the start and/or end dates should redraw the control
    document.getElementById('start_date').addEventListener('change', applyDates);
    document.getElementById('end_date').addEventListener('change', applyDates);


    // Function to apply the selected date range
    //document.getElementById('apply_dates').addEventListener('click', applyDates);


    document.getElementById('reset_dates').addEventListener('click', function() {
        var startDateInput = document.getElementById('start_date');
        var endDateInput = document.getElementById('end_date');

        startDateInput.value = '2017-07-30';
        endDateInput.value = todayStr();
        startDateInput.dispatchEvent(new Event('change'));
        //applyDates();
    });

    // Listen for manual changes to the control and update the date inputs
    google.visualization.events.addListener(control, 'statechange', function() {
      var state = control.getState();
      if (state.range) {
        if (state.range.start) {
          var startDate = new Date(state.range.start);
          document.getElementById('start_date').value = startDate.toISOString().split('T')[0];
        }
        if (state.range.end) {
          var endDate = new Date(state.range.end);
          document.getElementById('end_date').value = endDate.toISOString().split('T')[0];
        }
      }
      applyDatesExceptControlRange();
    });


  }
</script>

<script type="text/javascript">
function applyYear(year) {
    var startDateInput = document.getElementById('start_date');
    var endDateInput = document.getElementById('end_date');

    startDateInput.value = year + '-01-01';
    endDateInput.value = year + '-12-31';
    startDateInput.dispatchEvent(new Event('change'));
};
</script>

<script type="text/javascript">
  function toggleStaticImage() {
    var button = document.getElementById('static_toggle');
    var div = document.getElementById('png');
    if (div.style.display !== 'none') {
      div.style.display = 'none';
      //button.innerHTML = 'Show Static Image';
    } else {
      div.style.display = 'block';
      //button.innerHTML = 'Hide Static Image';
    }
  };
</script>

<script type="text/javascript">
  function toggleChartDetails() {
    for (let i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      for (let j = 0; j < sheet.cssRules.length; j++) {
        var rule = sheet.cssRules[j];
        if (rule.selectorText === '.chart_details_div') {
          if (rule.style.display !== 'none') {
            rule.style.display = 'none';
          } else {
            rule.style.display = 'block';
          }
        }
      }
    }
  };
</script>

<script type="text/javascript">
  function toggleElement(id) {
    var element = document.getElementById(id);
    var disabled = element.disabled;
    if (element.disabled) {
      element.disabled = false;
    } else {
      element.disabled = true;
    }
  };

  function toggleTrendlineDegree() {
    var ids = ["trendline_degree", "degree_up", "degree_down"];
    var i;
    for (i = 0; i < ids.length; i++) {
      toggleElement(ids[i]);
    }
  };
</script>

<script type="text/javascript">
  function changeDegree(val) {
    var degree = document.getElementById('trendline_degree');
    var newval = parseInt(degree.value) + parseInt(val);
    if (newval < 1) {
      newval = 1;
    } else if (newval > 32) {
      newval = 32;
    }
    degree.value = newval;

    // we have to fire the change event ourselves
    var event = new CustomEvent("change");
    degree.dispatchEvent(event);
  };

</script>

<style>
  .chart_details_div {
    display: none;
  }

  .google-tooltip {
    font-size: 15px;
    padding: 5px 5px 5px 5px;
    font-family: Arial, Helvetica;
  }

table, th, td {
  border: 2px solid black;
  border-collapse: collapse;
}

th, td {
  text-align: center;
  vertical-align: middle;
  padding: 5px;
}


.highlighted {}

.highlighted {
    background-color: lightgreen;
}

</style>

</head><body>

<div id="dashboard_div">
<div id="chart_div"></div>
<div id="control_div"></div>
</div>


<br><br>

<div id="date_selectors">
<b><u>Adjust Selected Date Range</u></b>
<br>
<label for="start_date">Start Date:</label>
<input type="date" id="start_date" value="2017-07-30">
<br>
<label for="end_date">End Date:</label>
<input type="date" id="end_date">
<br><br>

<!--
<script type="text/javascript">
document.getElementById('end_date').value = todayStr();
</script>
-->

<!--
<button id="apply_dates">Apply Date Range</button>
<br><br>
-->

<button id="reset_dates">Reset to Full Date Range</button>
</div>

<br><br>

Last Game Acquired on <b> {{ last_acquired }} </b>
(<span id="dayDiff"></span> ago)
<br>
Currently Unplayed: <b> {{ unplayed_count }} </b>
(Lowest Since <b> {{ lowest_since }}) </b>
<br><br>

<!-- tooltip toggling not working -->
<b>Tooltip Details:</b>
<input id='chart_details_toggle' type='checkbox' onclick="toggleChartDetails()">
<br><br>
<!-- -->

<b>Trendline:</b>
<input id='trendline_toggle' type='checkbox' onclick="toggleTrendlineDegree()">
<br>
<b>Degree:</b>
<input type='text' id='trendline_degree' value='2' disabled readonly style="width: 2em; text-align: center">
<button id='degree_up' type='button' disabled onclick='changeDegree(1)'>+</button>
<button id='degree_down' type='button' disabled onclick='changeDegree(-1)'>-</button>
<br><br>

{{ yearly_stats }}

<!--
<br><br>
<b><u>Stats: <span id="start_date_str">2017-07-30</span> to <span id="end_date_str">End</span></u></b>
<br><b>Starting Count: </b><span id="variable_stats_starting_count"></span>
<br><b>Ending Count: </b><span id="variable_stats_ending_count"></span>
<br><b>Net Change: </b><span id="variable_stats_net_change"></span>
<br><b>Games Acquired: </b><span id="variable_stats_games_acquired"></span>
<br><b>Games Played: </b><span id="variable_stats_games_played"></span>
-->

<script type="text/javascript">
document.getElementById("end_date_str").innerHTML = todayStr();
updateVariableStatsForSelectedDateRange();
</script>

<br><br>

<script>
function toggleGBInfo() {
  var x = document.getElementById("game-breakers-info");
  if (x.style.display === "none") {
    x.style.display = "table-row";
  } else {
    x.style.display = "none";
  }
}
</script>

<table>
<tr>
<th colspan="3">
Game Breakers (Start: {{ game_breaker_start }})
<button class="btn info" style="float:right" onclick="toggleGBInfo()">&#8505;</button>
</th>
</tr>

<tr id="game-breakers-info" style="display:none"> <td colspan="3" style="text-align:left">

<div style="width: 450px; word-wrap: break-word">

At any given time, we track the number of days since the last game was acquired
(currently <span id="dayDiffGB"></span> ago, as noted above). Consider, then, the
following: at any given point in time, what is the highest number that <i>days since
Last Game Acquired</i> has ever been (up until that point)?

<br><br>

By definition, said highest number must either be reached on that very day (in
the middle of a long streak of no new game arrivals), or on some previous day
on which the streak was broken by a game's arrival (at which point we'd reset
to 0).

<br><br>

From here, we see an interesting set of data to track: for each time that <i>days since
Last Game Acquired</i> was the highest that it had ever been but then reset to 0, what day
did the reset happen on? What games arrived to cause the reset? What was that
highest-ever-at-the-time value?

<br><br>

This trio of questions is what Game Breakers tracks, starting from {{ game_breaker_start }}
and continuing until the present day.

</div>

</td> </tr>

<tr>
<th>Score</th><th>Date</th><th>Game(s)</th></tr>
{{ game_breaker_rows }}
</table>

<br>

Next Possible Gamebreaker Threshold: <b>{{ next_game_breaker_date }}</b> (Score: {{ next_game_breaker_count }})

<br><br>

<button id='static_toggle' type='button' onclick='toggleStaticImage()'>Toggle Static Image</button>

<div id='png' style="display:none"></div>

<br><br><br><img src="images/fine.png" />

<br><br>
<table id="sortableTable">
<thead>
<tr>
<th colspan="2">Unplayed Games ({{ unplayed_count }})</th>
</tr>
<tr>
<th onclick="sortTable(0)" style="cursor: pointer;" class="arrowHeader">Game ▲</th>
<th onclick="sortTable(1)" style="cursor: pointer;" class="arrowHeader">Date Acquired</th>
</tr>
</thead>
<tbody>
{{ unplayed_lines }}
</tbody>
</table>

<br>
<b>Highlight Unplayed Games Acquired in Selected Date Range: </b>
<input type="checkbox" id="enable-unplayed-highlighting" />

<script>
    // count days since we last got a new game
    var last_acquired = {{ js_last_acquired }} ;
    var today = new Date();
    today.setHours(0,0,0,0);
    var diff = Math.abs(today - last_acquired);
    var days = Math.floor(diff / (1000 * 60 * 60 * 24));

    // "day" if 1 day, "days" otherwise
    var plural = "s";
    if (days == 1) {
      plural = "";
    }

    // write the answer to our html
    const ids = ["dayDiff", "dayDiffGB"];
    const elementsList = document.querySelectorAll(ids.map(id => `#${id}`).join(', '));
    const elementsArray = [...elementsList];
    elementsArray.forEach(div => {
        div.textContent = days + " day" + plural;
    });

</script>

<script>
function sortTable(columnIndex) {
    const table = document.getElementById("sortableTable");
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    
    // Determine current sort direction
    const currentDir = table.dataset.sortDir || 'asc';
    const currentCol = table.dataset.sortCol;
    
    // Toggle direction if clicking the same column, otherwise default to asc
    const dir = (currentCol == columnIndex && currentDir == 'asc') ? 'desc' : 'asc';
    
    // Helper function to extract all text from a cell, replacing links with their text
    function getCellText(cell) {
        let text = cell.innerHTML;
        const links = cell.querySelectorAll('a');
        links.forEach(link => {
            text = text.replace(link.outerHTML, link.innerText);
        });
        // Remove any remaining HTML tags and trim
        return text.replace(/<[^>]*>/g, '').trim();
    }
    
    // Sort the rows array
    rows.sort((rowA, rowB) => {
        let cellA = getCellText(rowA.cells[columnIndex]);
        let cellB = getCellText(rowB.cells[columnIndex]);
        
        const comparison = cellA.localeCompare(cellB);
        return dir == 'asc' ? comparison : -comparison;
    });
    
    // Re-append rows in sorted order
    rows.forEach(row => tbody.appendChild(row));
    
    // Store the current sort state
    table.dataset.sortDir = dir;
    table.dataset.sortCol = columnIndex;
    
    // Update arrow indicators
    updateSortArrows(columnIndex, dir);
}

function updateSortArrows(columnIndex, direction) {
    const headers = document.querySelectorAll('#sortableTable th.arrowHeader');
    headers.forEach((header, index) => {
        // Remove existing arrows
        header.innerHTML = header.innerHTML.replace(/ ▲| ▼/g, '');
        
        // Add arrow to the sorted column
        if (index == columnIndex) {
            header.innerHTML += direction == 'asc' ? ' ▲' : ' ▼';
        }
    });
}
</script>

<script>
var checkbox = document.getElementById("enable-unplayed-highlighting");

function updateUnplayedGamesHighlighting() {
    const checkbox_is_selected = document.getElementById('enable-unplayed-highlighting').value === "checked";

    const start_date_as_str = document.getElementById('start_date').value;
    const end_date_as_str = document.getElementById('end_date').value;

    const highlightable_elements = document.querySelectorAll('.highlightedIfInDateRange');
    highlightable_elements.forEach(function(element) {
        const cells_in_row = element.cells;
        const date_cell = cells_in_row[1].innerText;
        const is_in_date_range = (start_date_as_str <= date_cell) && (date_cell <= end_date_as_str);
        const should_highlight = is_in_date_range && checkbox_is_selected;
        const is_already_highlighted = element.classList.contains('highlighted');
        if (should_highlight && !is_already_highlighted) {
            element.classList.add('highlighted');
        } else if (!should_highlight && is_already_highlighted) {
            element.classList.remove('highlighted');
        }
    });
};
checkbox.addEventListener("change", updateUnplayedGamesHighlighting);
</script>


<br><br><br>
<b><u>Some BGG lookups handled by the BGG XML API:</u></b>
<br>
<a href="https://boardgamegeek.com/using_the_xml_api"><img src="images/powered_by_bgg.jpg" alt="Powered by BGG" /></a>

</body></html>
